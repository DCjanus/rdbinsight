<!DOCTYPE html>
<html lang="en" data-theme="dracula">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDBInsight Report</title>

    <!-- Tailwind CSS & DaisyUI -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script type="text/tailwindcss">
        module.exports = {
            daisyui: {
                themes: ["dracula"],
            },
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', '"Segoe UI"', 'Roboto', '"Helvetica Neue"', 'Arial', '"Noto Sans"', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', '"Liberation Mono"', '"Courier New"', 'monospace'],
                    }
                }
            }
        }
    </script>

    <!-- d3-flame-graph CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.1.3/dist/d3-flamegraph.css" type="text/css">

    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <!-- D3.js and d3-flame-graph -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.1.3/dist/d3-flamegraph.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.1.3/dist/d3-flamegraph-tooltip.min.js"></script>

    <style>
        /* Custom styles for d3-flame-graph integration with DaisyUI */
        .d3-flame-graph rect {
            stroke: hsl(var(--b1)); /* Use DaisyUI background-1 for strokes */
            stroke-width: 0.5;
            transition: all 0.2s ease;
        }
        .d3-flame-graph rect:hover {
            stroke-width: 1.5px;
            filter: brightness(1.1);
        }
        .d3-flame-graph-label {
            pointer-events: none;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            font-size: 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        .d3-flame-graph .fade {
            opacity: 0.6 !important;
        }
        #flame-chart-details {
            transition: opacity 0.2s ease-in-out;
        }
        /* Style for sort icons */
        .sort-icon {
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }
        th:hover .sort-icon {
            opacity: 1;
        }
        .sort-icon.active {
            opacity: 1;
            color: hsl(var(--p)); /* Use DaisyUI primary color */
        }
        [v-cloak] {
            display: none;
        }
        /* Tooltip style override to handle long text */
        .tooltip::before {
            max-width: 50vw; /* Limit max width to half of viewport */
            white-space: normal; /* Allow wrapping */
            word-break: break-all; /* Break long words */
        }
    </style>
</head>
<body class="bg-base-200 font-sans">
    <div id="app" class="p-4 lg:p-6 max-w-screen-2xl mx-auto" v-cloak>
        <!-- Header -->
        <header class="navbar bg-base-100 rounded-2xl shadow-md mb-6">
            <div class="navbar-start">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3 text-primary" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><path d="M12 10.5c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM12 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                <h1 class="text-xl font-bold">RDBInsight</h1>
            </div>
            <div class="navbar-end hidden lg:flex items-center space-x-6">
                <copyable-text :text="raw.cluster" label="Cluster:" :max-length="20"></copyable-text>
                <copyable-text :text="raw.batch" label="Batch:" :max-length="28"></copyable-text>
                <button class="btn btn-ghost btn-sm" @click="exportJsonData">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                    Export JSON
                </button>
            </div>
        </header>

        <!-- Stats -->
        <div class="stats stats-vertical lg:stats-horizontal shadow-md w-full mb-6">
            <div class="stat">
                <div class="stat-title">Total RDB Size</div>
                <div class="stat-value">{{ formatSize(totalSize) }}</div>
                <div class="stat-desc">{{ totalSize.toLocaleString() }} bytes</div>
            </div>
            <div class="stat">
                <div class="stat-title">Total Keys</div>
                <div class="stat-value">{{ totalKeys.toLocaleString() }}</div>
                <div class="stat-desc">Across all databases</div>
            </div>
            <div class="stat">
                <div class="stat-title">Instance Count</div>
                <div class="stat-value">{{ instanceDistribution.length }}</div>
                <div class="stat-desc">Redis instances reporting</div>
            </div>
             <div class="stat">
                <div class="stat-title">Database Count</div>
                <div class="stat-value">{{ dbDistribution.length }}</div>
                <div class="stat-desc">Databases with keys</div>
            </div>
        </div>

        <!-- Cluster Issues Insight -->
        <div class="card bg-base-100 shadow-md mb-6">
            <div class="card-body">
                <h2 class="card-title">Cluster Issues Insight</h2>
                <p class="text-base-content/70 mb-4">Detected performance and operational issues that require attention.</p>
                
                <!-- No Issues Message -->
                <div v-if="!hasClusterIssues" class="text-base-content/60 text-sm italic text-center py-4">
                    No cluster issues detected.
                </div>
                
                <!-- Big Keys Section -->
                <div v-if="raw.cluster_issues && raw.cluster_issues.big_keys && raw.cluster_issues.big_keys.length > 0" class="collapse collapse-arrow bg-base-200 mb-4">
                    <input type="checkbox" />
                    <div class="collapse-title text-lg font-medium flex items-center">
                        Big Keys
                        <div class="badge badge-error ml-2">{{ raw.cluster_issues.big_keys.length }}</div>
                    </div>
                    <div class="collapse-content">
                        <div class="text-sm text-base-content/70 mb-4">
                            String keys > 1MB, non-string keys > 1GB
                        </div>
                        <div class="overflow-x-auto">
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Key Name</th>
                                        <th>Instance</th>
                                        <th>DB</th>
                                        <th>Type</th>
                                        <th>RDB Size</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="bigKey in raw.cluster_issues.big_keys" :key="bigKey.key_base64">
                                        <td>
                                            <copyable-text :text="decodeAndFormatKey(bigKey.key_base64)" :max-length="40"></copyable-text>
                                        </td>
                                        <td>
                                            <copyable-text :text="bigKey.instance" :max-length="30"></copyable-text>
                                        </td>
                                        <td>{{ bigKey.db }}</td>
                                        <td>
                                            <span class="badge" :class="`badge-${getTypeTagColor(bigKey.type)}`">{{ bigKey.type }}</span>
                                        </td>
                                        <td class="font-mono">{{ formatSize(bigKey.rdb_size) }}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Codis Cross-Instance Slot Section -->
                <div v-if="raw.cluster_issues && raw.cluster_issues.codis_slot_skew" class="collapse collapse-arrow bg-base-200 mb-4">
                    <input type="checkbox" />
                    <div class="collapse-title text-lg font-medium flex items-center">
                        Codis Cross-Instance Slot
                        <div class="badge badge-warning ml-2">Detected</div>
                    </div>
                    <div class="collapse-content">
                        <div class="alert alert-warning">
                            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                            <span>Codis slot data found across multiple Redis instances. This may indicate configuration issues or data migration problems.</span>
                        </div>
                    </div>
                </div>

                <!-- Redis Cluster Cross-Instance Slot Section -->
                <div v-if="raw.cluster_issues && raw.cluster_issues.redis_cluster_slot_skew" class="collapse collapse-arrow bg-base-200 mb-4">
                    <input type="checkbox" />
                    <div class="collapse-title text-lg font-medium flex items-center">
                        Redis Cluster Cross-Instance Slot
                        <div class="badge badge-warning ml-2">Detected</div>
                    </div>
                    <div class="collapse-content">
                        <div class="alert alert-warning">
                            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                            <span>Redis Cluster slot data found across multiple instances. This may indicate cluster resharding issues or configuration problems.</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Distributions -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <!-- By Type -->
            <div class="card bg-base-100 shadow-md">
                <div class="card-body">
                    <h2 class="card-title">By Data Type</h2>
                    <div class="space-y-2 max-h-96 overflow-y-auto pr-2">
                        <div v-for="item in typeDistribution" :key="item.type">
                            <div class="flex justify-between text-sm mb-1">
                                <span class="font-semibold badge" :class="`badge-${getTypeTagColor(item.type)}`">{{ item.type }}</span>
                                <span class="font-mono">{{ formatSize(item.size) }} ({{ item.percentage.toFixed(1) }}%)</span>
                            </div>
                            <progress class="progress w-full" :class="`progress-${getTypeTagColor(item.type)}`" :value="item.percentage" max="100"></progress>
                        </div>
                    </div>
                </div>
            </div>
            <!-- By DB -->
            <div class="card bg-base-100 shadow-md">
                <div class="card-body">
                    <h2 class="card-title">By Database</h2>
                    <div class="space-y-2 max-h-96 overflow-y-auto pr-2">
                        <div v-for="item in dbDistribution" :key="item.db">
                             <div class="flex justify-between text-sm mb-1">
                                <span class="font-semibold badge badge-info">DB {{ item.db }}</span>
                                <span class="font-mono">{{ formatSize(item.size) }} ({{ item.percentage.toFixed(1) }}%)</span>
                            </div>
                            <progress class="progress progress-info w-full" :value="item.percentage" max="100"></progress>
                        </div>
                    </div>
                </div>
            </div>
            <!-- By Instance -->
            <div class="card bg-base-100 shadow-md">
                <div class="card-body">
                    <h2 class="card-title">By Instance</h2>
                    <div class="space-y-2 max-h-96 overflow-y-auto pr-2">
                        <div v-for="item in instanceDistribution" :key="item.instance">
                             <div class="flex justify-between text-sm mb-1">
                                <div class="tooltip tooltip-right" :data-tip="item.instance">
                                    <span class="font-semibold badge badge-neutral">{{ item.shortName }}</span>
                                </div>
                                <span class="font-mono">{{ formatSize(item.size) }} ({{ item.percentage.toFixed(1) }}%)</span>
                            </div>
                            <progress class="progress progress-neutral w-full" :value="item.percentage" max="100"></progress>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Flame Graph -->
        <div class="card bg-base-100 shadow-md mb-6">
            <div class="card-body">
                <div class="card-title flex flex-col md:flex-row justify-between items-start md:items-center">
                    <h2 class="mb-2 md:mb-0">Memory Distribution Flame Graph</h2>
                    <div class="flex items-center space-x-2">
                        <input type="text" v-model="searchTerm" @input="onSearchInput" placeholder="Search prefixes" class="input input-bordered input-sm w-full md:w-auto">
                        <button class="btn btn-sm btn-outline" @click="resetZoom">Reset Zoom</button>
                    </div>
                </div>
                <div class="bg-base-200 rounded-lg p-1 min-h-[400px] flex items-end">
                    <div id="flame-chart" class="w-full"></div>
                </div>
                <div id="flame-chart-details" class="text-center text-sm font-mono p-2 bg-base-300 rounded-lg mt-2 min-h-[2.5rem] flex items-center justify-center">
                    Hover over a frame for details, or click to zoom.
                </div>
            </div>
        </div>

        <!-- Top 100 Big Keys -->
        <div class="card bg-base-100 shadow-md">
            <div class="card-body">
                <div class="card-title flex flex-col md:flex-row justify-between items-start md:items-center">
                    <div class="mb-4 md:mb-0">
                        <h2 class="text-xl">Top 100 Big Keys</h2>
                        <p class="text-sm font-normal text-base-content/70">Showing {{ sortedTopKeys.length }} of {{ raw.top_keys.length }} keys. Click headers to sort.</p>
                    </div>
                    <div class="flex flex-col md:flex-row gap-2 items-stretch md:items-center w-full md:w-auto">
                        <input type="text" v-model="topKeysSearchTerm" placeholder="Search key names..." class="input input-bordered input-sm w-full md:w-64">
                        <button class="btn btn-ghost btn-sm" @click="exportTopKeysCSV">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                            Export CSV
                        </button>
                    </div>
                </div>
                <div class="overflow-auto max-h-96">
                    <table class="table table-sm table-zebra w-full">
                        <thead class="sticky top-0 z-10">
                            <tr>
                                <th v-for="col in topKeysTableColumns" :key="col.key" @click="setSort(col.key)" class="cursor-pointer bg-base-100">
                                    <div class="flex items-center">
                                        {{ col.label }}
                                        <svg v-if="col.sortable" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-1 sort-icon" :class="{ 'active': sort.key === col.key }" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path v-if="sort.key === col.key && sort.order === 'asc'" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
                                            <path v-else stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </div>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="key in sortedTopKeys" :key="key.key">
                                <td class="font-mono">
                                    <copyable-text :text="decodeAndFormatKey(key.key_base64)" :max-length="40"></copyable-text>
                                </td>
                                <td class="font-mono text-right">{{ formatSize(key.rdb_size) }}</td>
                                <td><span class="badge" :class="`badge-${getTypeTagColor(key.type)}`">{{ key.type }}</span></td>
                                <td class="font-mono">
                                    <copyable-text :text="key.instance" :max-length="30"></copyable-text>
                                </td>
                                <td class="text-center">{{ key.db }}</td>
                                <td class="text-right">{{ formatMemberCount(key.member_count) }}</td>
                                <td class="font-mono">{{ key.encoding }}</td>
                                <td>
                                    <copyable-text :text="formatExpireTimeForDisplay(key.expire_at)" :copy-text="getExpireTimeForCopy(key.expire_at)"></copyable-text>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script id="rdbinsight-data" type="application/json" src="./report.json"></script>
    <script>
        const { createApp, ref, computed, onMounted, watch, nextTick, defineComponent } = Vue;

        const CopyableText = defineComponent({
            props: {
                text: { type: String, required: true },
                copyText: { type: String, default: '' },
                label: { type: String, default: '' },
                maxLength: { type: Number, default: 0 },
            },
            template: `
                <div class="tooltip tooltip-bottom" :data-tip="copyText || text">
                    <div class="group flex items-center font-mono text-sm cursor-pointer hover:bg-base-200 p-1 rounded-md transition-colors" @click="copy">
                        <span v-if="label" class="text-base-content/60 mr-2">{{ label }}</span>
                        <span class="font-semibold" :class="{ 'truncate': maxLength > 0 }" :style="maxLength > 0 ? { 'max-width': maxLength + 'ch' } : {}">{{ text }}</span>
                        <div class="w-5 h-5 ml-1.5 shrink-0">
                            <svg v-if="isCopied" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                            </svg>
                            <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-base-content/60 opacity-0 group-hover:opacity-100 transition-opacity" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 5h7a2 2 0 012 2v12a2 2 0 01-2 2H9a2 2 0 01-2-2V7a2 2 0 012-2zm-4 4H5a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V19" />
                            </svg>
                        </div>
                    </div>
                </div>
            `,
            setup(props) {
                const isCopied = ref(false);
                const copy = async () => {
                    if (isCopied.value) return;
                    try {
                        await navigator.clipboard.writeText(props.copyText || props.text);
                        isCopied.value = true;
                        setTimeout(() => {
                            isCopied.value = false;
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                    }
                };
                return { isCopied, copy };
            }
        });

        const app = createApp({
            components: {
                CopyableText
            },
            setup() {
                // --- STATE ---
                const raw = ref({
                    cluster: 'loading...',
                    batch: 'loading...',
                    db_aggregates: [],
                    type_aggregates: [],
                    instance_aggregates: [],
                    top_keys: [],
                    top_prefixes: [],
                    cluster_issues: {
                        big_keys: [],
                        codis_slot_skew: false,
                        redis_cluster_slot_skew: false
                    }
                });
                const dataLoaded = ref(false);
                const searchTerm = ref('');
                const topKeysSearchTerm = ref('');
                const flameGraph = ref(null);
                const sort = ref({ key: 'rdb_size', order: 'desc' });
                
                // --- COMPUTED ---
                const totalSize = computed(() => raw.value.db_aggregates.reduce((sum, item) => sum + item.total_size, 0));
                const totalKeys = computed(() => raw.value.db_aggregates.reduce((sum, item) => sum + item.key_count, 0));

                const typeDistribution = computed(() => {
                    const total = totalSize.value;
                    if (!total) return [];
                    return raw.value.type_aggregates
                        .map(item => ({ type: item.data_type, size: item.total_size, percentage: (item.total_size / total) * 100 }))
                        .sort((a, b) => b.size - a.size);
                });

                const dbDistribution = computed(() => {
                    const total = totalSize.value;
                    if (!total) return [];
                    return raw.value.db_aggregates
                        .map(item => ({ db: item.db, size: item.total_size, percentage: (item.total_size / total) * 100 }))
                        .sort((a, b) => a.db - b.db);
                });

                const instanceDistribution = computed(() => {
                    const total = totalSize.value;
                    if (!total) return [];
                    return raw.value.instance_aggregates.map(item => ({
                        instance: item.instance,
                        shortName: item.instance.includes(':') ? item.instance.split(':').slice(-2).join(':') : (item.instance.length > 20 ? '...' + item.instance.slice(-17) : item.instance),
                        size: item.total_size,
                        percentage: total > 0 ? (item.total_size / total) * 100 : 0
                    })).sort((a, b) => b.size - a.size);
                });

                const hasClusterIssues = computed(() => {
                    const issues = raw.value.cluster_issues;
                    if (!issues) return false;
                    return (issues.big_keys && issues.big_keys.length > 0) ||
                           issues.codis_slot_skew ||
                           issues.redis_cluster_slot_skew;
                });

                const topKeysTableColumns = ref([
                    { key: 'key_base64', label: 'Key Name', sortable: true },
                    { key: 'rdb_size', label: 'RDB Size', sortable: true },
                    { key: 'type', label: 'Type', sortable: true },
                    { key: 'instance', label: 'Instance', sortable: true },
                    { key: 'db', label: 'DB', sortable: true },
                    { key: 'member_count', label: 'Members', sortable: true },
                    { key: 'encoding', label: 'Encoding', sortable: true },
                    { key: 'expire_at', label: 'Expires', sortable: true },
                ]);

                const searchedTopKeys = computed(() => {
                    if (!raw.value.top_keys) return [];
                    const term = topKeysSearchTerm.value.toLowerCase();
                    if (!term) return raw.value.top_keys;
                    return raw.value.top_keys.filter(key => decodeAndFormatKey(key.key_base64).toLowerCase().includes(term));
                });
                
                const sortedTopKeys = computed(() => {
                    const data = [...searchedTopKeys.value];
                    const { key, order } = sort.value;
                    if (!key) return data;

                    return data.sort((a, b) => {
                        let valA = a[key];
                        let valB = b[key];

                        if (key === 'key_base64') {
                            valA = decodeAndFormatKey(valA);
                            valB = decodeAndFormatKey(valB);
                        }

                        if (typeof valA === 'string' && typeof valB === 'string') {
                            return order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                        }
                        return order === 'asc' ? valA - valB : valB - valA;
                    });
                });

                // --- METHODS ---
                const setSort = (key) => {
                    if (sort.value.key === key) {
                        sort.value.order = sort.value.order === 'asc' ? 'desc' : 'asc';
                    } else {
                        sort.value.key = key;
                        sort.value.order = 'desc';
                    }
                };
                
                const formatSize = (bytes) => {
                    if (typeof bytes !== 'number' || isNaN(bytes)) return 'N/A';
                    if (bytes === 0) return '0 B';
                    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(1024));
                    return `${parseFloat((bytes / Math.pow(1024, i)).toFixed(2))} ${units[i]}`;
                };
                
                const formatMemberCount = (count) => {
                    if (count == null) return 'N/A';
                    if (count >= 1000000) return `${(count / 1000000).toFixed(1)}M`;
                    if (count >= 1000) return `${(count / 1000).toFixed(1)}K`;
                    return count.toString();
                };

                const getTypeTagColor = (type) => ({'string': 'success', 'hash': 'info', 'list': 'warning', 'set': 'error', 'zset': 'primary', 'stream': 'accent'}[type] || 'neutral');

                const decodeAndFormatKey = (base64Key) => {
                    try {
                        const binaryString = atob(base64Key);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                        try {
                            return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
                        } catch (error) {
                            return Array.from(bytes).map(byte => byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : `\\x${byte.toString(16).padStart(2, '0')}`).join('');
                        }
                    } catch (error) {
                        return base64Key; // Fallback
                    }
                };

                const decodeAndFormatPrefix = (base64Prefix) => {
                    try {
                        const binaryString = atob(base64Prefix);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                        try {
                            return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
                        } catch (error) {
                            return Array.from(bytes).map(byte => byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : `\\x${byte.toString(16).padStart(2, '0')}`).join('');
                        }
                    } catch (error) {
                        return base64Prefix; // Fallback
                    }
                };
                
                const formatExpireTimeForDisplay = (expireAt) => {
                    if (!expireAt) return 'Never';
                    try {
                        const date = new Date(expireAt);
                        return isNaN(date.getTime()) ? 'Invalid' : date.toLocaleString();
                    } catch { return 'Invalid'; }
                };

                const getExpireTimeForCopy = (expireAt) => expireAt || 'Never';

                // Convert top_prefixes data to flame graph format
                const convertToFlameGraphData = () => {
                    const prefixes = raw.value.top_prefixes;
                    if (!prefixes?.length) return null;

                    // Build node map for efficient lookup
                    const nodeMap = new Map();
                    prefixes.forEach(item => {
                        const decodedPrefix = decodeAndFormatPrefix(item.prefix_base64);
                        nodeMap.set(decodedPrefix, {
                            prefix: decodedPrefix,
                            total_size: item.total_size,
                            key_count: item.key_count,
                            children: [],
                            fullName: decodedPrefix
                        });
                    });

                    // Build tree structure based on string prefix containment (not colon-delimited)
                    // This works with dynamic LCP (Longest Common Prefix) algorithm results
                    const rootNodes = [];
                    const allPrefixes = Array.from(nodeMap.keys()).sort((a, b) => a.length - b.length);
                    
                    // For each prefix, find its immediate parent (longest prefix that contains it)
                    allPrefixes.forEach(prefix => {
                        const node = nodeMap.get(prefix);
                        let parentNode = null;
                        let longestParentLength = 0;
                        
                        // Find the longest existing prefix that this prefix starts with
                        for (const candidateParent of allPrefixes) {
                            if (candidateParent !== prefix && 
                                prefix.startsWith(candidateParent) && 
                                candidateParent.length > longestParentLength) {
                                parentNode = nodeMap.get(candidateParent);
                                longestParentLength = candidateParent.length;
                            }
                        }
                        
                        if (parentNode) {
                            parentNode.children.push(node);
                        } else {
                            // No parent found, this is a root node
                            rootNodes.push(node);
                        }
                    });

                    // Extract short names for display (relative to parent prefix)
                    const computeDisplayNames = (nodes, parentPrefix = '') => {
                        nodes.forEach(node => {
                            // Display name is the part after removing parent prefix
                            if (parentPrefix && node.prefix.startsWith(parentPrefix)) {
                                node.name = node.prefix.substring(parentPrefix.length) || node.prefix;
                            } else {
                                node.name = node.prefix;
                            }
                            
                            // Recursively compute names for children
                            if (node.children.length > 0) {
                                computeDisplayNames(node.children, node.prefix);
                            }
                        });
                    };
                    
                    computeDisplayNames(rootNodes);

                    // Sort children alphabetically for consistent layout
                    const sortChildren = (node) => {
                        if (node.children.length > 0) {
                            node.children.sort((a, b) => a.name.localeCompare(b.name));
                            node.children.forEach(sortChildren);
                        }
                    };
                    rootNodes.forEach(sortChildren);

                    // For proper flame graph rendering, we need to use selfValue(true) 
                    // and calculate self-values correctly for hierarchical data
                    const calculateSelfValues = (nodes) => {
                        nodes.forEach(node => {
                            const childrenTotalSize = node.children.reduce((sum, child) => sum + child.total_size, 0);
                            node.value = Math.max(0, node.total_size - childrenTotalSize);
                            if (node.children.length > 0) {
                                calculateSelfValues(node.children);
                            }
                        });
                    };
                    calculateSelfValues(rootNodes);
                    
                    // Create root node representing total memory
                    const totalMemory = totalSize.value;
                    const rootNodesTotal = rootNodes.reduce((sum, node) => sum + node.total_size, 0);
                    
                    
                    return {
                        name: 'Total Memory',
                        fullName: 'Total Memory', 
                        children: rootNodes,
                        value: Math.max(0, totalMemory - rootNodesTotal), // Self-value of root
                        key_count: totalKeys.value,
                        total_size: totalMemory
                    };
                };

                // Initialize flame graph with d3-flame-graph
                const initFlameGraph = () => {
                    const chartDom = document.getElementById('flame-chart');
                    const detailsDom = document.getElementById('flame-chart-details');
                    if (!chartDom || !detailsDom || !raw.value.top_prefixes?.length) return;
                    
                    chartDom.innerHTML = '';
                    const data = convertToFlameGraphData();
                    if (!data) return;

                    const clusterTotalMemory = totalSize.value;
                    
                    // Calculate percentage relative to total cluster memory
                    const getMemoryPercentage = (nodeValue) => {
                        return clusterTotalMemory > 0 ? ((nodeValue / clusterTotalMemory) * 100).toFixed(2) : '0.00';
                    };

                    // Configure tooltip using d3-flame-graph's built-in tooltip
                    const tooltip = flamegraph.tooltip.defaultFlamegraphTooltip()
                        .html(d => `
                            <div class="font-semibold text-sm">${d.data.fullName}</div>
                            <div class="text-xs mt-1">
                                <div>Keys: ${d.data.key_count.toLocaleString()}</div>
                                <div>Size: ${formatSize(d.data.total_size)} (${getMemoryPercentage(d.value)}%)</div>
                            </div>
                        `);

                    // Create and configure flame graph
                    flameGraph.value = flamegraph()
                        .width(chartDom.offsetWidth)
                        .cellHeight(18)
                        .transitionDuration(750)
                        .minFrameSize(5)
                        .selfValue(true)
                        .label(d => d.data.name || d.data.fullName)
                        .setColorHue('warm')
                        .tooltip(tooltip)
                        .onHover(d => {
                            if (d?.data?.fullName) {
                                const percentage = getMemoryPercentage(d.value);
                                detailsDom.innerHTML = `
                                    <span class="font-semibold">${d.data.fullName}</span> • 
                                    <span>Keys: ${d.data.key_count.toLocaleString()}</span> • 
                                    <span>Size: ${formatSize(d.data.total_size)} (${percentage}%)</span>
                                `;
                            } else {
                                detailsDom.textContent = 'Hover over a frame for details, or click to zoom.';
                            }
                        });

                    // Render the flame graph
                    d3.select(chartDom).datum(data).call(flameGraph.value);
                };

                // Reset flame graph zoom to root level
                const resetZoom = () => {
                    if (flameGraph.value) {
                        flameGraph.value.resetZoom();
                    }
                };

                // Search and highlight prefixes in flame graph
                const onSearchInput = () => {
                    if (!flameGraph.value) return;
                    
                    const term = searchTerm.value.trim();
                    if (term) {
                        // Use setSearchMatch to customize search behavior to search fullName
                        flameGraph.value.setSearchMatch((d, searchTerm, ignoreCase = true) => {
                            if (!d.data.fullName) return false;
                            // Simple case-insensitive string contains search
                            const fullName = ignoreCase ? d.data.fullName.toLowerCase() : d.data.fullName;
                            const term = ignoreCase ? searchTerm.toLowerCase() : searchTerm;
                            return fullName.includes(term);
                        });
                        flameGraph.value.search(term);
                    } else {
                        flameGraph.value.clear();
                    }
                };

                const exportJsonData = () => {
                    // Create a deep copy and enhance with human-readable fields
                    const enhancedData = JSON.parse(JSON.stringify(raw.value));
                    
                    // Add human-readable key field to top_keys
                    if (enhancedData.top_keys) {
                        enhancedData.top_keys = enhancedData.top_keys.map(key => ({
                            key: decodeAndFormatKey(key.key_base64),
                            ...key
                        }));
                    }
                    
                    // Add human-readable prefix field to top_prefixes
                    if (enhancedData.top_prefixes) {
                        enhancedData.top_prefixes = enhancedData.top_prefixes.map(prefix => ({
                            prefix: decodeAndFormatPrefix(prefix.prefix_base64),
                            ...prefix
                        }));
                    }
                    
                    // Add human-readable key field to cluster_issues.big_keys
                    if (enhancedData.cluster_issues && enhancedData.cluster_issues.big_keys) {
                        enhancedData.cluster_issues.big_keys = enhancedData.cluster_issues.big_keys.map(bigKey => ({
                            key: decodeAndFormatKey(bigKey.key_base64),
                            ...bigKey
                        }));
                    }
                    
                    enhancedData.exported_at = new Date().toISOString();
                    
                    const dataStr = JSON.stringify(enhancedData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const safe_batch = raw.value.batch.replace(/[:.]/g, '-').replace(/\+/g, '_');
                    link.download = `rdb_report_${raw.value.cluster}_${safe_batch}.json`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                };

                const exportTopKeysCSV = () => {
                    // CSV header - updated to include raw numeric columns
                    const headers = [
                        'Key Name', 'RDB Size (Bytes)', 'RDB Size (Human)', 'Type', 'Instance', 'DB', 
                        'Member Count (Raw)', 'Member Count (Human)', 'Encoding', 'Expires'
                    ];
                    const csvContent = [headers.join(',')];
                    
                    // Export all top keys (sortedTopKeys includes filtering and sorting)
                    sortedTopKeys.value.forEach(key => {
                        const row = [
                            `"${decodeAndFormatKey(key.key_base64).replace(/"/g, '""')}"`, // Escape quotes in CSV
                            key.rdb_size, // Raw bytes (already numeric)
                            `"${formatSize(key.rdb_size)}"`, // Human readable size
                            key.type,
                            `"${key.instance.replace(/"/g, '""')}"`,
                            key.db,
                            key.member_count || '', // Raw member count (numeric)
                            `"${formatMemberCount(key.member_count)}"`, // Human readable member count
                            key.encoding || '',
                            `"${getExpireTimeForCopy(key.expire_at).replace(/"/g, '""')}"`
                        ];
                        csvContent.push(row.join(','));
                    });
                    
                    const csvStr = csvContent.join('\n');
                    const blob = new Blob([csvStr], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const safe_batch = raw.value.batch.replace(/[:.]/g, '-').replace(/\+/g, '_');
                    link.download = `rdb_top_keys_${raw.value.cluster}_${safe_batch}.csv`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                };

                const loadReportData = async () => {
                    try {
                        const scriptElement = document.getElementById('rdbinsight-data');
                        const inlineData = scriptElement.textContent.trim();
                        if (inlineData) return JSON.parse(inlineData);
                        
                        const src = scriptElement.getAttribute('src');
                        if (!src) throw new Error('No data source specified');
                        
                        const response = await fetch(src);
                        if (!response.ok) throw new Error(`Failed to fetch data: ${response.status}`);
                        return await response.json();
                    } catch (error) {
                        console.error('Failed to load report data:', error);
                        return {
                            cluster: 'Error', batch: 'Failed to load data',
                            db_aggregates: [], type_aggregates: [], instance_aggregates: [],
                            top_keys: [], top_prefixes: [],
                            cluster_issues: { big_keys: [], codis_slot_skew: false, redis_cluster_slot_skew: false }
                        };
                    }
                };
                
                // --- LIFECYCLE ---
                onMounted(async () => {
                    const data = await loadReportData();
                    raw.value = data;
                    document.title = `RDBInsight Report - ${raw.value.cluster}`;
                    dataLoaded.value = true;
                    
                    nextTick(() => {
                        initFlameGraph();
                        window.addEventListener('resize', () => initFlameGraph());
                    });
                });

                return {
                    raw, dataLoaded, searchTerm, topKeysSearchTerm, sort,
                    totalSize, totalKeys, typeDistribution, dbDistribution, instanceDistribution, hasClusterIssues,
                    topKeysTableColumns, sortedTopKeys,
                    formatSize, formatMemberCount, getTypeTagColor, decodeAndFormatKey, decodeAndFormatPrefix,
                    formatExpireTimeForDisplay, getExpireTimeForCopy,
                    resetZoom, onSearchInput, exportJsonData, exportTopKeysCSV, setSort
                };
            }
        });

        app.mount('#app');
    </script>
</body>
</html>
